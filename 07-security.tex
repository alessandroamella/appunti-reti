\input{preambolo_comune}

% --- Titolo ---
\title{Appunti su Sicurezza nelle Reti di Calcolatori \\ (Capitolo 8)}
\author{Basato sulle slide del Prof.} % Nome del prof. omesso come da richiesta
\date{\today}
\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Cos'è la Sicurezza di Rete?}
\label{sec:cos_e_sicurezza}

La sicurezza di rete si basa su alcuni pilastri fondamentali:

\begin{enumerate}[label=\arabic*.]
    \item \textbf{Riservatezza (Confidentiality):}
    \begin{itemize}
        \item Solo il mittente e il destinatario intenzionale dovrebbero essere in grado di \textit{comprendere} il contenuto del messaggio.
        \item Si ottiene tramite:
        \begin{itemize}
            \item Il mittente \textbf{crittografa} il messaggio.
            \item Il destinatario \textbf{decrittografa} il messaggio.
        \end{itemize}
        \item \textit{Esempio pratico:} Quando inserisci la password per l'home banking, vuoi che solo la banca possa leggerla, non un malintenzionato che intercetta la comunicazione.
    \end{itemize}

    \item \textbf{Autenticazione (Authentication):}
    \begin{itemize}
        \item Sia il mittente che il destinatario vogliono confermare l'identità l'uno dell'altro.
        \item \textit{Esempio pratico:} La banca vuole essere sicura che sei tu a fare login, e tu vuoi essere sicuro di star parlando con il vero sito della banca e non con un sito fasullo.
    \end{itemize}

    \item \textbf{Integrità del Messaggio (Message Integrity):}
    \begin{itemize}
        \item Mittente e destinatario vogliono assicurarsi che il messaggio non sia stato alterato (durante il transito o successivamente) senza che ciò venga rilevato.
        \item \textit{Esempio pratico:} Se invii un bonifico da 100€, vuoi che la banca riceva 100€ e non 10.000€ perché qualcuno ha modificato l'importo.
    \end{itemize}

    \item \textbf{Accesso e Disponibilità (Access and Availability):}
    \begin{itemize}
        \item I servizi devono essere accessibili e disponibili per gli utenti legittimi.
        \item \textit{Esempio pratico:} Il sito della tua università deve essere raggiungibile quando hai bisogno di consultare gli orari delle lezioni, e non reso irraggiungibile da un attacco.
    \end{itemize}
\end{enumerate}

\subsection{Personaggi Comuni in Sicurezza}
\begin{itemize}
    \item \textbf{Alice e Bob:} Due entità (persone, sistemi) che vogliono comunicare in modo sicuro.
    \item \textbf{Trudy (Intruder):} L'antagonista che cerca di intercettare, cancellare o aggiungere messaggi.
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=2cm and 4cm, auto]
        \node (alice) [actor, text=black] {Alice};
        \node (bob) [actor, text=black, right=of alice] {Bob};
        \node (trudy) [intruder, above = 0.7cm of alice, xshift=2cm] {Trudy};

        \draw[message_r] (alice.east) -- node[midway, above, sloped, text=primarytext] {canale dati/controllo} (bob.west);
        \draw[->, red, thick, dashed] (trudy.north) |- ($(alice.east)!0.5!(bob.west)$) node[right, text=red, yshift=-0.2cm] {intercetta};
    \end{tikzpicture}
    \caption{Scenario base: Alice, Bob e l'intruso Trudy.}
\end{figure}

\subsection{Chi sono Alice e Bob nella vita reale?}
\begin{itemize}
    \item Persone che si scambiano email.
    \item Browser web e server web durante transazioni elettroniche (es. acquisti online).
    \item Client e server di online banking.
    \item Server DNS.
    \item Router che si scambiano aggiornamenti delle tabelle di routing.
\end{itemize}

\subsection{Cosa può fare un \textit{cattivo} (Trudy)?}
\begin{itemize}
    \item \textbf{Eavesdrop (Origliare):} Intercettare messaggi.
    \item \textbf{Insert (Inserire attivamente):} Introdurre messaggi falsi nella connessione.
    \item \textbf{Impersonation (Impersonificazione/Spoofing):} Fingere di essere qualcun altro, ad es. falsificando l'indirizzo IP sorgente in un pacchetto.
    \item \textbf{Hijacking (Dirottamento):} \textquotedblleft Prendere il controllo\textquotedblright{} di una connessione esistente, sostituendosi al mittente o al destinatario.
    \item \textbf{Denial of Service (DoS - Negazione del Servizio):} Impedire che un servizio venga utilizzato da altri, ad es. sovraccaricando le risorse del server.
\end{itemize}

\section{Principi di Crittografia}
\label{sec:principi_crittografia}

\subsection{Il Linguaggio della Crittografia}
\begin{itemize}
    \item $m$ (\textbf{plaintext}): Il messaggio originale, in chiaro.
    \item \textbf{Algoritmo di Crittografia (Encryption Algorithm):} Processo per trasformare il plaintext.
    \item \textbf{Chiave di Crittografia ($K_A$):} Un valore segreto usato dall'algoritmo per crittografare.
    \item $K_A(m)$ (\textbf{ciphertext}): Il messaggio crittografato, illeggibile senza la chiave.
    \item \textbf{Algoritmo di Decrittografia (Decryption Algorithm):} Processo per ritrasformare il ciphertext in plaintext.
    \item \textbf{Chiave di Decrittografia ($K_B$):} Un valore segreto usato dall'algoritmo per decrittografare.
    \item Se le chiavi $K_A$ e $K_B$ sono le stesse (o facilmente derivabili l'una dall'altra), si parla di \textbf{crittografia simmetrica}. Se sono diverse e non derivabili, si parla di \textbf{crittografia asimmetrica (o a chiave pubblica)}.
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=1.2cm and 1.5cm, auto]
        % First row
        \node (plaintext1) [block, text=black] {plaintext ($m$)};
        \node (enc_algo) [process, right=of plaintext1, text=black] {Encryption Algorithm};
        \node (ciphertext) [block, right=of enc_algo, text=black] {ciphertext $K_A(m)$};
        
        % Trudy (moved above ciphertext)
        \node (trudy_crypto) [intruder, above=of ciphertext] {Trudy};
        
        % Second row
        \node (dec_algo) [process, below=of ciphertext, text=black] {Decryption Algorithm};
        \node (plaintext2) [block, right=of dec_algo, text=black] {plaintext ($m$)};
        
        % Keys
        \node (keyA) [key, above=0.3cm of enc_algo, label=left:Alice's Key, text=black] {$K_A$};
        \node (keyB) [key, above=0.3cm of dec_algo, label=right:Bob's Key, text=black] {$K_B$};

        % Connections
        \draw[dataflow] (plaintext1) -- (enc_algo);
        \draw[dataflow] (keyA) -- (enc_algo);
        \draw[dataflow] (enc_algo) -- (ciphertext);
        \draw[dataflow] (ciphertext) -- (dec_algo);
        \draw[dataflow] (keyB) -- (dec_algo);
        \draw[dataflow] (dec_algo) -- (plaintext2);
        \draw[->, red, dashed] (trudy_crypto) -- (ciphertext);
    \end{tikzpicture}
    \caption{Flusso base della crittografia.}
\end{figure}

\subsection{Rompere uno Schema di Crittografia (Attacchi)}
\begin{enumerate}
    \item \textbf{Ciphertext-only attack} Trudy ha solo il ciphertext e cerca di decifrarlo.
    \begin{itemize}
        \item \textbf{Brute force:} Provare tutte le possibili chiavi.
        \item \textbf{Analisi statistica:} Analizzare le frequenze delle lettere/simboli.
    \end{itemize}
    \item \textbf{Known-plaintext attack} Trudy ha accesso a coppie di plaintext e al corrispondente ciphertext.
    \item \textbf{Chosen-plaintext attack} Trudy può scegliere dei plaintext, farli crittografare dal sistema e ottenere i ciphertext corrispondenti.
\end{enumerate}

\subsection{Crittografia a Chiave Simmetrica}
\begin{itemize}
    \item Alice e Bob condividono la \textbf{stessa chiave segreta ($K_S$)}.
    \item \textit{Problema:} Come fanno Alice e Bob a concordare la chiave $K_S$ in modo sicuro?
\end{itemize}

\subsubsection{Notazione Formale Crittografia Simmetrica}
\label{ssubsec:notazione_simmetrica}
Data una chiave simmetrica $K_S$ condivisa tra Alice e Bob, e un messaggio in chiaro $m$:
\begin{itemize}
    \item Crittografia (eseguita da Alice): $c = E_{K_S}(m)$
    \item Decrittografia (eseguita da Bob): $m = D_{K_S}(c)$
\end{itemize}
Dove $E$ è l'algoritmo di crittografia e $D$ quello di decrittografia, e si assume che $D_{K_S}(E_{K_S}(m)) = m$.
Nelle slide viene spesso usato $K_S(m)$ per indicare $E_{K_S}(m)$.

\subsubsection{Cifrario a Sostituzione Semplice (Monoalfabetico)}
\begin{itemize}
    \item Ogni lettera del plaintext è sostituita da un'altra lettera.
    \item \textit{Esempio plaintext:} \texttt{abcdefghijklmnopqrstuvwxyz}
    \item \textit{Esempio ciphertext:} \texttt{mnbvcxzasdfghjklpoiuytrewq}
    \item La \textbf{chiave di crittografia} è la mappatura. Debole all'analisi statistica.
\end{itemize}

\subsubsection{DES (Data Encryption Standard)}
\begin{itemize}
    \item Standard USA (NIST 1993), ora obsoleto per molte applicazioni.
    \item Chiave simmetrica a \textbf{56 bit}, input plaintext a 64 bit.
    \item \textbf{Block cipher} con \textbf{cipher block chaining (CBC)}.
    \item \textbf{Sicurezza:} Una chiave a 56 bit può essere trovata con brute force in meno di un giorno.
    \item \textbf{3DES (Triple DES):} Crittografa 3 volte con 3 chiavi diverse. Più sicuro ma più lento.
    \item \textbf{Funzionamento DES (generale):} Permutazione iniziale, 16 \textit{round} identici con sotto-chiavi diverse, permutazione finale.
\end{itemize}

\subsubsection{AES (Advanced Encryption Standard)}
\begin{itemize}
    \item Standard NIST che ha sostituito DES (Novembre 2001).
    \item Processa dati in blocchi da \textbf{128 bit}.
    \item Chiavi simmetriche da \textbf{128, 192, o 256 bit}.
    \item \textbf{Sicurezza:} Considerato molto sicuro. Un attacco brute force su AES (128 bit) impiegherebbe trilioni di anni.
\end{itemize}

\subsection{Crittografia a Chiave Pubblica (Asimmetrica)}
\begin{itemize}
    \item Mittente e destinatario \textbf{non} condividono una chiave segreta.
    \item Ogni utente ha una coppia di chiavi:
    \begin{itemize}
        \item \textbf{Chiave Pubblica ($K_B^+$):} Conosciuta da tutti. Usata per crittografare messaggi destinati a Bob o per verificare firme digitali di Bob.
        \item \textbf{Chiave Privata ($K_B^-$):} Conosciuta solo dal proprietario (Bob). Usata per decrittografare messaggi crittografati con la sua chiave pubblica o per firmare digitalmente messaggi.
    \end{itemize}
\end{itemize}
\textit{Flusso (Alice invia a Bob):} plaintext ($m$) $\xrightarrow{K_B^+}$ ciphertext ($K_B^+(m)$) $\xrightarrow{K_B^-}$ plaintext ($m$)

\subsubsection{Notazione Formale Crittografia a Chiave Pubblica}
\label{ssubsec:notazione_asimmetrica}
Bob possiede una coppia di chiavi: pubblica $K_B^+$ e privata $K_B^-$.
Alice vuole inviare un messaggio $m$ a Bob in modo confidenziale.
\begin{itemize}
    \item Alice crittografa con la chiave pubblica di Bob: $c = E_{K_B^+}(m)$
    \item Bob decrittografa con la sua chiave privata: $m = D_{K_B^-}(c)$
\end{itemize}
Si deve avere $D_{K_B^-}(E_{K_B^+}(m)) = m$.
Nelle slide viene spesso usato $K_B^+(m)$ per $E_{K_B^+}(m)$ e $K_B^-(c)$ per $D_{K_B^-}(c)$.
La proprietà fondamentale è $K_B^-(K_B^+(m)) = m$.

\subsubsection{RSA (Rivest, Shamir, Adelson Algorithm)}
\begin{itemize}
    \item L'algoritmo a chiave pubblica più diffuso.
    \item \textbf{Prerequisito: Aritmetica Modulare}
    \begin{itemize}
        \item $x \pmod n$: resto della divisione di $x$ per $n$.
        \item Proprietà: $(a \pmod n)^d \pmod n = a^d \pmod n$.
    \end{itemize}
    \item \textbf{Creazione della Coppia di Chiavi Pubblica/Privata RSA:}
    \begin{enumerate}
        \item Scegliere due numeri primi grandi, $p$ e $q$.
        \item Calcolare $n = p \cdot q$ e $z = (p-1)(q-1)$.
        \item Scegliere $e$ (con $e<n$) tale che $e$ e $z$ siano relativamente primi.
        \item Scegliere $d$ tale che $e \cdot d \equiv 1 \pmod z$.
        \item \textbf{Chiave Pubblica:} $K_B^+ = (n, e)$
        \item \textbf{Chiave Privata:} $K_B^- = (n, d)$
    \end{enumerate}
    \item \textbf{Crittografia e Decrittografia RSA:}
    \begin{itemize}
        \item Crittografare $m$ ($m < n$): $c = m^e \pmod n$
        \item Decrittografare $c$: $m = c^d \pmod n$
        \item Quindi: $m = (m^e \pmod n)^d \pmod n$
    \end{itemize}
    \item \textbf{Altra Proprietà Importante di RSA (Commutatività):}
    $K_B^-(K_B^+(m)) = m$ e $K_B^+(K_B^-(m)) = m$. La seconda forma è usata per le firme digitali.
    \item \textbf{Perché RSA è sicuro?} Si basa sulla difficoltà computazionale di \textbf{fattorizzare numeri molto grandi} ($n$).
    \item \textbf{RSA in Pratica: Chiavi di Sessione (Session Keys):}
    RSA è lento. Si usa RSA per scambiare una \textbf{chiave simmetrica di sessione ($K_S$)}, e poi si usa AES/DES (più veloci) con $K_S$ per i dati.
\end{itemize}

\subsubsection{Proprietà dell'Aritmetica Modulare per RSA}
\label{ssubsec:prop_mod_rsa}
Alcune proprietà utili:
\begin{itemize}
    \item $[(a \pmod n) + (b \pmod n)] \pmod n = (a+b) \pmod n$
    \item $[(a \pmod n) - (b \pmod n)] \pmod n = (a-b) \pmod n$
    \item $[(a \pmod n) \cdot (b \pmod n)] \pmod n = (a \cdot b) \pmod n$
    \item Quindi, $(a \pmod n)^d \pmod n = a^d \pmod n$.
\end{itemize}
Un risultato cruciale per la correttezza di RSA, derivante dal Teorema di Eulero (o Piccolo Teorema di Fermat se $p,q$ sono primi e $n=pq$), è che se $ed \equiv 1 \pmod{\phi(n)}$ (dove $\phi(n)=(p-1)(q-1)=z$ nel nostro caso), allora $m^{ed} \equiv m \pmod n$.
Più precisamente, la dimostrazione si basa su:
$c^d \pmod n = (m^e)^d \pmod n = m^{ed} \pmod n$.
Poiché $ed \equiv 1 \pmod z$, possiamo scrivere $ed = k \cdot z + 1$ per qualche intero $k$.
Quindi $m^{ed} \pmod n = m^{kz+1} \pmod n$.
Usando la proprietà $x^y \pmod n = x^{(y \pmod z)} \pmod n$ (che non è universalmente vera così scritta, ma il concetto è che l'esponente opera modulo $z=\phi(n)$), otteniamo:
$m^{ed} \pmod n = m^{(ed \pmod z)} \pmod n = m^1 \pmod n = m \pmod n$.

\subsubsection{Esempio Pratico RSA}
\label{ssubsec:esempio_rsa}
Bob sceglie:
\begin{itemize}
    \item Primi $p=5, q=7$.
    \item $n = p \cdot q = 5 \cdot 7 = 35$.
    \item $z = (p-1)(q-1) = (4)(6) = 24$.
    \item $e=5$ (relativamente primo con $z=24$, cioè $\text{gcd}(5,24)=1$).
    \item $d=29$ (infatti $e \cdot d = 5 \cdot 29 = 145$. $145 \pmod{24} = (6 \cdot 24 + 1) \pmod{24} = 1$).
\end{itemize}
Chiave pubblica di Bob: $(n,e) = (35,5)$.
Chiave privata di Bob: $(n,d) = (35,29)$.

Alice vuole inviare $m=12$ (NB: $m<n$).
\begin{itemize}
    \item \textbf{Crittografia (Alice):} $c = m^e \pmod n = 12^5 \pmod{35}$.
    $12^2 = 144 \equiv 4 \pmod{35}$.
    $12^4 \equiv 4^2 = 16 \pmod{35}$.
    $12^5 = 12^4 \cdot 12 \equiv 16 \cdot 12 = 192 \pmod{35}$.
    $192 = 5 \cdot 35 + 17 \Rightarrow 192 \equiv 17 \pmod{35}$. Quindi $c=17$.
    Alice invia $c=17$.
    \item \textbf{Decrittografia (Bob):} $m' = c^d \pmod n = 17^{29} \pmod{35}$.
    Questo calcolo è più lungo, ma il risultato sarà $m'=12$.
\end{itemize}

\subsubsection{Dimostrazione della Commutatività di RSA}
\label{ssubsec:comm_rsa_proof}
Vogliamo mostrare che $K_B^+(K_B^-(m)) = m$.
Sia $K_B^-(m) = m^d \pmod n$.
Allora $K_B^+(K_B^-(m)) = K_B^+(m^d \pmod n) = (m^d \pmod n)^e \pmod n$.
Per le proprietà dell'aritmetica modulare, questo è $ (m^d)^e \pmod n = m^{de} \pmod n$.
Poiché $de \equiv 1 \pmod z$, come visto prima, $m^{de} \pmod n = m \pmod n$.
Questo dimostra che l'ordine di applicazione di crittografia con una chiave e decrittografia con l'altra chiave della stessa coppia (pubblica/privata) restituisce il messaggio originale, indipendentemente da quale operazione (elevamento a $e$ o a $d$) viene fatta prima.
\begin{itemize}
    \item $K_B^-(K_B^+(m)) = (m^e)^d \pmod n = m^{ed} \pmod n = m$ (riservatezza)
    \item $K_B^+(K_B^-(m)) = (m^d)^e \pmod n = m^{de} \pmod n = m$ (base per firme digitali)
\end{itemize}

\section{Integrità dei Messaggi e Autenticazione}
\label{sec:integrita_autenticazione}

\subsection{Autenticazione}
\textbf{Obiettivo:} Bob vuole che Alice \textquotedblleft provi\textquotedblright{} la sua identità.

\begin{itemize}
    \item \textbf{Protocollo ap1.0:} Alice: \textquotedblleft Sono Alice\textquotedblright{}. \textit{Fail:} Trudy può dirlo.
    \item \textbf{Protocollo ap2.0:} Alice: \textquotedblleft Sono Alice\textquotedblright{} (con IP di Alice). \textit{Fail:} Trudy può fare IP spoofing.
    \item \textbf{Protocollo ap3.0:} Alice: \textquotedblleft Sono Alice\textquotedblright{} + password. \textit{Fail:} Playback attack.
    \item \textbf{Protocollo ap3.1:} Alice: \textquotedblleft Sono Alice\textquotedblright{} + password crittografata. \textit{Fail:} Playback attack funziona ancora.
    \item \textbf{Protocollo ap4.0: Autenticazione con Nonce (per evitare playback):}
    \begin{itemize}
        \item \textbf{Nonce (R):} Numero usato una sola volta.
        \item Passaggi:
        \begin{enumerate}
            \item Alice $\rightarrow$ Bob: \textquotedblleft Sono Alice\textquotedblright{}.
            \item Bob $\rightarrow$ Alice: $R$ (nonce).
            \item Alice $\rightarrow$ Bob: $K_{A-B}(R)$ (nonce crittografato con chiave condivisa).
        \end{enumerate}
        \item \textit{Problema:} Richiede una chiave simmetrica $K_{A-B}$ condivisa.
    \end{itemize}
    \item \textbf{Protocollo ap5.0: Autenticazione con Nonce e Chiave Pubblica:}
    \begin{enumerate}
        \item Alice $\rightarrow$ Bob: \textquotedblleft Sono Alice\textquotedblright{}.
        \item Bob $\rightarrow$ Alice: $R$ (nonce).
        \item (Alice chiede la chiave pubblica di Bob, $K_A^+$).
        \item Alice $\rightarrow$ Bob: $K_A^-(R)$ (nonce crittografato con la chiave \textit{privata} di Alice).
        \item Bob verifica con $K_A^+(K_A^-(R)) \stackrel{?}{=} R$.
    \end{enumerate}
    \textit{Falla di Sicurezza ap5.0:} \textbf{Man-in-the-Middle (MITM) Attack}. Trudy si frappone e scambia le sue chiavi pubbliche con Alice e Bob.
\end{itemize}

\subsubsection{Flusso di Messaggi ap4.0}
\label{ssubsec:ap4_0_flow}
Obiettivo: Alice si autentica con Bob usando una chiave simmetrica condivisa $K_{A-B}$ e un nonce $R$ per prevenire replay.
\begin{enumerate}
    \item Alice $\rightarrow$ Bob: ``Sono Alice'' (identificativo di Alice)
    \item Bob $\rightarrow$ Alice: $R$ (Nonce generato da Bob)
    \item Alice $\rightarrow$ Bob: $K_{A-B}(R)$ (Alice crittografa $R$ con la chiave condivisa)
\end{enumerate}
Bob decrittografa $K_{A-B}(R)$ usando $K_{A-B}$. Se il risultato è $R$, Alice è autenticata e "live".

\subsubsection{Flusso di Messaggi ap5.0}
\label{ssubsec:ap5_0_flow}
Obiettivo: Alice si autentica con Bob usando la sua coppia di chiavi pubblica/privata ($K_A^+, K_A^-$) e un nonce $R$.
\begin{enumerate}
    \item Alice $\rightarrow$ Bob: ``Sono Alice'' (identificativo di Alice)
    \item Bob $\rightarrow$ Alice: $R$ (Nonce generato da Bob)
    \item Alice $\rightarrow$ Bob: $K_A^-(R)$ (Alice "firma" $R$ crittografandolo con la sua chiave privata $K_A^-$)
\end{enumerate}
Bob ottiene la chiave pubblica di Alice $K_A^+$ (da un certificato o altra fonte fidata) e calcola $K_A^+(K_A^-(R))$. Se il risultato è $R$, Alice è autenticata.
Questo protocollo è vulnerabile all'attacco Man-in-the-Middle se $K_A^+$ non è ottenuta in modo sicuro.

\subsection{Firme Digitali (Digital Signatures)}
\begin{itemize}
    \item Tecnica crittografica analoga alle firme autografe.
    \item \textbf{Obiettivi:}
    \begin{itemize}
        \item Mittente (Bob) firma, stabilendo proprietà/creazione.
        \item \textbf{Verificabile e Non Falsificabile}.
        \item \textbf{Non Ripudio (Non-repudiation):} Bob non può negare di aver firmato.
    \end{itemize}
    \item \textbf{Firma Digitale Semplice per $m$ (usando RSA):}
    \begin{enumerate}
        \item Bob firma $m$ con la sua \textbf{chiave privata $K_B^-$}: $K_B^-(m)$.
        \item Bob invia ad Alice $(m, K_B^-(m))$.
        \item Alice verifica applicando la \textbf{chiave pubblica di Bob $K_B^+$} alla firma: $K_B^+(K_B^-(m))$.
        \item Se il risultato è $m$, la firma è valida.
    \end{enumerate}
\end{itemize}

\subsection{Digest dei Messaggi (Funzioni Hash Crittografiche)}
Crittografare messaggi lunghi con chiave pubblica è costoso.
\begin{itemize}
    \item \textbf{Obiettivo:} Creare un'\textquotedblleft impronta digitale\textquotedblright{} (\textit{fingerprint}) di lunghezza fissa.
    \item Si applica una \textbf{funzione hash $H$} al messaggio $m$ per ottenere un digest $H(m)$.
    \item \textbf{Proprietà delle Funzioni Hash Crittografiche:}
    \begin{itemize}
        \item Output di lunghezza fissa.
        \item \textbf{Resistenza alla preimmagine (One-way):} Dato $H(m)$, difficile trovare $m$.
        \item \textbf{Resistenza alla seconda preimmagine:} Dato $m_1$, difficile trovare $m_2 \neq m_1$ t.c. $H(m_1) = H(m_2)$.
        \item \textbf{Resistenza alle collisioni:} Difficile trovare $m_1 \neq m_2$ t.c. $H(m_1) = H(m_2)$.
    \end{itemize}
    \item \textbf{Internet Checksum:} NON è una funzione hash crittografica (debole).
    \item \textbf{Firma Digitale con Message Digest:}
    \begin{enumerate}
        \item \textbf{Bob (mittente):}
        \begin{enumerate}
            \item Calcola $H(m)$.
            \item Firma il digest: $K_B^-(H(m))$.
            \item Invia $(m, K_B^-(H(m)))$.
        \end{enumerate}
        \item \textbf{Alice (destinatario):}
        \begin{enumerate}
            \item Riceve $m$ e $S_B = K_B^-(H(m))$.
            \item Calcola $H(m')$ dal messaggio $m'$ ricevuto.
            \item Decrittografa la firma: $H_{firmato} = K_B^+(S_B)$.
            \item Confronta $H(m')$ con $H_{firmato}$. Se uguali, firma valida e messaggio integro.
        \end{enumerate}
    \end{enumerate}
    \item \textbf{Algoritmi di Hash Comuni:} MD5 (insicuro), SHA-1 (debole), SHA-2 (SHA-256, SHA-512 - raccomandati).
\end{itemize}

\subsubsection{Passaggi Dettagliati Firma Digitale con Digest}
\label{ssubsec:firma_digest_dettagli}
Sia $m$ il messaggio, $H$ la funzione hash, $K_B^-$ la chiave privata di Bob, $K_B^+$ la chiave pubblica di Bob.

\textbf{Processo di Firma (Bob):}
\begin{enumerate}
    \item Calcolare il digest del messaggio: $h = H(m)$.
    \item Crittografare il digest con la chiave privata di Bob (firma): $S_B = K_B^-(h) = K_B^-(H(m))$.
    \item Inviare il messaggio e la firma ad Alice: $(m, S_B)$.
\end{enumerate}

\textbf{Processo di Verifica (Alice):}
\begin{enumerate}
    \item Ricevere $(m', S'_B)$ da Bob (usiamo $m'$ e $S'_B$ per indicare che potrebbero essere stati alterati).
    \item Calcolare il digest del messaggio ricevuto: $h' = H(m')$.
    \item Decrittografare la firma ricevuta usando la chiave pubblica di Bob: $h_{firmato} = K_B^+(S'_B)$.
    \item Confrontare i due digest: $h' \stackrel{?}{=} h_{firmato}$.
    \item Se sono uguali, la firma è valida: il messaggio è integro e autenticato (proviene da Bob). Altrimenti, la verifica fallisce.
\end{enumerate}

\subsection{Certificazione della Chiave Pubblica (Public-Key Certification)}
Risolve il problema del MITM per lo scambio di chiavi pubbliche.
\begin{itemize}
    \item \textbf{Autorità di Certificazione (CA - Certification Authority):} Entità fidata che lega una chiave pubblica a un'entità E.
    \item \textbf{Processo:}
    \begin{enumerate}
        \item L'entità E (es. Bob) si registra presso una CA (prova d'identità + chiave pubblica).
        \item La CA crea un \textbf{certificato digitale} contenente: identità di E, chiave pubblica di E, info CA, validità, ecc.
        \item La CA \textbf{firma digitalmente} questo certificato con la \textbf{chiave privata della CA}.
    \end{enumerate}
    \item \textbf{Utilizzo del Certificato:}
    \begin{enumerate}
        \item Alice ottiene il certificato di Bob.
        \item Alice usa la chiave pubblica della CA (che deve conoscere/fidarsi) per verificare la firma sul certificato di Bob.
        \item Se la firma della CA è valida, Alice si fida che la chiave pubblica nel certificato sia di Bob.
    \end{enumerate}
\end{itemize}

\subsubsection{Formato e Verifica del Certificato Digitale (Concettuale)}
\label{ssubsec:certificato_digitale_formato}
Un certificato digitale per Bob, emesso dalla CA, contiene tipicamente:
\begin{itemize}
    \item Identificativo di Bob
    \item Chiave Pubblica di Bob ($K_B^+$)
    \item Identificativo della CA
    \item Periodo di validità
    \item Algoritmo di firma usato dalla CA
    \item Altre informazioni...
\end{itemize}
Chiamiamo tutto questo blocco di informazioni $I_{Bob}$.
La CA firma questo blocco: $S_{CA} = K_{CA}^-(H(I_{Bob}))$.
Il certificato finale è $(I_{Bob}, S_{CA})$.

Quando Alice riceve il certificato di Bob:
\begin{enumerate}
    \item Estrae $I_{Bob}$ e $S_{CA}$.
    \item Calcola $H(I_{Bob})$.
    \item Usa la chiave pubblica della CA, $K_{CA}^+$ (che Alice deve possedere e fidarsi), per verificare la firma: $H_{verificato} = K_{CA}^+(S_{CA})$. (Se la firma è solo $K_{CA}^-(I_{Bob})$, allora la verifica è $K_{CA}^+(S_{CA})$ e si confronta con $I_{Bob}$).
    \item Se $H(I_{Bob}) = H_{verificato}$, allora Alice si fida che $K_B^+$ in $I_{Bob}$ appartenga veramente a Bob.
\end{enumerate}

\section{Protezione delle E-mail}
\label{sec:protezione_email}

Alice vuole inviare email sicure a Bob (riservatezza, autenticazione, integrità).

\subsection{Solo Riservatezza}
\begin{enumerate}
    \item \textbf{Alice:}
    \begin{enumerate}
        \item Genera chiave simmetrica casuale $K_S$.
        \item Crittografa $m$ con $K_S$: $K_S(m)$.
        \item Crittografa $K_S$ con la chiave pubblica di Bob $K_B^+$: $K_B^+(K_S)$.
        \item Invia $(K_S(m), K_B^+(K_S))$.
    \end{enumerate}
    \item \textbf{Bob:}
    \begin{enumerate}
        \item Usa $K_B^-$ per decrittografare $K_B^+(K_S) \rightarrow K_S$.
        \item Usa $K_S$ per decrittografare $K_S(m) \rightarrow m$.
    \end{enumerate}
\end{enumerate}

\subsection{Solo Autenticazione e Integrità}
\begin{enumerate}
    \item \textbf{Alice:}
    \begin{enumerate}
        \item Calcola $H(m)$.
        \item Firma $H(m)$ con la sua chiave privata $K_A^-$: $K_A^-(H(m))$.
        \item Invia $(m, K_A^-(H(m)))$.
    \end{enumerate}
    \item \textbf{Bob:}
    Verifica la firma usando $K_A^+$ e confrontando $H(m)$.
\end{enumerate}

\subsection{Riservatezza + Autenticazione + Integrità (PGP-like)}
\begin{enumerate}
    \item \textbf{Alice:}
    \begin{enumerate}
        \item Firma $H(m)$ con $K_A^- \rightarrow S_A = K_A^-(H(m))$.
        \item $M' = m \mathbin{\|} S_A$.
        \item Genera $K_S$.
        \item Crittografa $M'$ con $K_S \rightarrow C_1 = K_S(M')$.
        \item Crittografa $K_S$ con $K_B^+ \rightarrow C_2 = K_B^+(K_S)$.
        \item Invia $(C_1, C_2)$.
    \end{enumerate}
    \item \textbf{Bob:}
    Processo inverso per ottenere $m$ e verificare $S_A$.
\end{enumerate}
Alice usa tre chiavi: la sua privata, la pubblica di Bob, e la $K_S$ simmetrica.

\subsection{Schema Combinato per E-mail Sicura (PGP-like)}
\label{ssec:email_pgp_like}
Alice vuole inviare un'e-mail $m$ a Bob garantendo riservatezza, autenticazione del mittente e integrità del messaggio.
Chiavi coinvolte:
\begin{itemize}
    \item Alice: $K_A^+, K_A^-$
    \item Bob: $K_B^+, K_B^-$
    \item Chiave di sessione simmetrica casuale: $K_S$
\end{itemize}

\textbf{Operazioni di Alice (Mittente):}
\begin{enumerate}
    \item \textbf{Firma:} Alice calcola il digest $H(m)$ e lo firma con la sua chiave privata: $S_A = K_A^-(H(m))$.
    \item \textbf{Preparazione del Payload:} Alice concatena il messaggio originale con la sua firma: $P = m \mathbin{\|} S_A$.
    \item \textbf{Crittografia Simmetrica:} Alice genera una chiave di sessione simmetrica casuale $K_S$. Crittografa il payload $P$ con $K_S$: $C_P = K_S(P) = K_S(m \mathbin{\|} K_A^-(H(m)))$.
    \item \textbf{Crittografia della Chiave di Sessione:} Alice crittografa la chiave di sessione $K_S$ con la chiave pubblica di Bob: $C_K = K_B^+(K_S)$.
    \item \textbf{Invio:} Alice invia $(C_P, C_K)$ a Bob.
\end{enumerate}

\textbf{Operazioni di Bob (Destinatario):}
\begin{enumerate}
    \item \textbf{Decrittografia della Chiave di Sessione:} Bob usa la sua chiave privata $K_B^-$ per decrittografare $C_K$ e ottenere $K_S$: $K_S = K_B^-(C_K)$.
    \item \textbf{Decrittografia Simmetrica:} Bob usa $K_S$ per decrittografare $C_P$ e ottenere il payload $P = m \mathbin{\|} S_A$.
    \item \textbf{Verifica della Firma:}
        \begin{itemize}
            \item Bob estrae $m$ e $S_A$ da $P$.
            \item Bob calcola il digest del messaggio $m$ ricevuto: $H(m)$.
            \item Bob usa la chiave pubblica di Alice $K_A^+$ per verificare la firma $S_A$: $H_{verificato} = K_A^+(S_A)$.
            \item Se $H(m) = H_{verificato}$, il messaggio è autentico (da Alice) e integro.
        \end{itemize}
\end{enumerate}

\subsubsection{Esempio d'Esame Adattato}
\textit{Domanda: Alice spedisce M1 (grande) a Bob (solo non ripudio, no privacy). Bob risponde con m2 (piccolo) ad Alice (garanzia mittente, privacy, no replay). Costo minimo.}

\textbf{Fase 1: Alice $\rightarrow$ Bob (M1, grande, solo non ripudio)}
Non serve crittografare M1. Non ripudio è dato da firma digitale.
\begin{itemize}
    \item Alice calcola $H(M1)$.
    \item Alice firma $H(M1)$ con la sua chiave privata: $S_{A1} = K_A^-(H(M1))$.
    \item Alice invia a Bob: $(M1, S_{A1})$.
\end{itemize}
Bob verifica la firma usando $K_A^+$. Questo è efficiente perché si firma solo l'hash.

\textbf{Fase 2: Bob $\rightarrow$ Alice (m2, piccolo, mittente, privacy, no replay)}
\begin{itemize}
    \item \textbf{Garanzia Mittente (Bob):} Bob firma $m2$ (o $H(m2)$ se $m2$ non fosse piccolo) con la sua chiave privata $K_B^-$. Per includere il no-replay, si firma $(m2 \mathbin{\|} R)$, dove $R$ è un nonce. Firma: $S_{B2} = K_B^-(H(m2 \mathbin{\|} R))$ (o $K_B^-(m2 \mathbin{\|} R)$ se $m2 \mathbin{\|} R$ è piccolo abbastanza per RSA).
    \item \textbf{Payload da crittografare:} $P_2 = (m2 \mathbin{\|} R \mathbin{\|} S_{B2})$.
    \item \textbf{Privacy (per Alice):} Bob crittografa $P_2$ con la chiave pubblica di Alice $K_A^+$ (essendo $m2$ piccolo, si può crittografare direttamente tutto il payload firmato con RSA senza usare una $K_S$ intermedia).
    Ciphertext: $C_2 = K_A^+(P_2) = K_A^+(m2 \mathbin{\|} R \mathbin{\|} S_{B2})$.
    \item Bob invia a Alice: $C_2$.
    \item \textbf{Nonce R:} Può essere generato da Bob, oppure Alice potrebbe averlo inviato a Bob in un precedente messaggio non specificato qui, o potrebbe essere un contatore/timestamp. Se Bob lo genera, Alice deve poterlo validare (es. se è un contatore atteso).
\end{itemize}
Alice decrittografa $C_2$ con $K_A^-$, estrae $m2, R, S_{B2}$. Verifica $R$ (per no-replay) e poi verifica $S_{B2}$ usando $K_B^+$.

\section{Protezione delle Connessioni TCP: SSL/TLS}
\label{sec:ssl_tls}
SSL (Secure Sockets Layer) / TLS (Transport Layer Security).

\begin{itemize}
    \item \textbf{Fornisce:} Riservatezza, Integrità, Autenticazione (server sempre, client opzionale).
    \item \textbf{Posizionamento:} Applicazione $\rightarrow$ \textbf{SSL/TLS} $\rightarrow$ TCP $\rightarrow$ IP.
\end{itemize}

\subsection{Fasi di SSL (Concettuale, \textquotedblleft Toy SSL\textquotedblright{})}
\begin{enumerate}
    \item \textbf{Handshake (Stretta di Mano):}
    \begin{itemize}
        \item Client e Server usano certificati e chiavi pubbliche/private per autenticarsi e scambiarsi un segreto condiviso (\textbf{Master Secret, MS}).
        \item Client genera un \textbf{Pre-Master Secret (PMS)}, lo crittografa con la chiave pubblica del server.
        \item Entrambi calcolano MS da PMS e nonce scambiati.
    \end{itemize}
    \item \textbf{Key Derivation (Derivazione delle Chiavi):}
    \begin{itemize}
        \item Da MS si derivano chiavi di sessione simmetriche (tipicamente 4: 2 per crittografia client $\leftrightarrow$ server, 2 per MAC client $\leftrightarrow$ server).
    \end{itemize}
    \item \textbf{Data Transfer (Trasferimento Dati):}
    \begin{itemize}
        \item Dati suddivisi in \textbf{record}.
        \item Ogni record: (Dati + MAC) crittografati + header SSL (tipo, versione, lunghezza).
        \item Numeri di sequenza impliciti nel MAC per prevenire replay/riordino.
        \item Tipi di record specifici per prevenire Truncation Attack.
    \end{itemize}
    \item \textbf{Connection Closure (Chiusura Connessione):}
    Messaggi speciali (alert \texttt{close\_notify}) per chiudere in modo sicuro.
\end{enumerate}

\subsubsection{Flusso Concettuale Toy SSL}
\label{ssubsec:toy_ssl_flow}
\textbf{1. Handshake:}
\begin{itemize}
    \item Client $\rightarrow$ Server: \texttt{hello}
    \item Server $\rightarrow$ Client: Certificato Pubblico del Server (contenente $K_{Server}^+$)
    \item Client $\rightarrow$ Server: $K_{Server}^+(MS)$ (Master Secret $MS$ crittografato con la chiave pubblica del server, risultato $EMS$)
\end{itemize}
Ora Client e Server condividono $MS$.

\textbf{2. Derivazione Chiavi:}
Da $MS$ (e altri dati come i nonce scambiati nell'hello), si derivano (usando una Key Derivation Function - KDF):
\begin{itemize}
    \item $K_c$: Chiave di crittografia Client $\rightarrow$ Server
    \item $M_c$: Chiave MAC Client $\rightarrow$ Server
    \item $K_s$: Chiave di crittografia Server $\rightarrow$ Client
    \item $M_s$: Chiave MAC Server $\rightarrow$ Client
\end{itemize}

\textbf{3. Trasferimento Dati (Record):}
Esempio: Client invia dati al Server.
\begin{itemize}
    \item Dati applicativi suddivisi. Per un frammento di dati $D$:
    \item Calcolo MAC: $MAC_D = \text{MAC}_{M_c}(D \mathbin{\|} \text{seq_num} \mathbin{\|} \text{type})$
    \item Crittografia: $C_D = E_{K_c}(D \mathbin{\|} MAC_D)$
    \item Record SSL: \texttt{[Header (type, version, length)] [Encrypted Data $C_D$]}
\end{itemize}
Il campo `type` può indicare dati applicativi, alert (es. chiusura), ecc. `seq_num` è un numero di sequenza per prevenire replay.

\textbf{4. Chiusura:}
Messaggio di tipo "closure" (es. \texttt{type 1}) inviato come un record protetto.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=1.5cm and 2cm, auto]
        \node (client) [actor, text=black] {Client (Alice)};
        \node (server) [actor, text=black, right=6cm of client] {Server (Bob)};

        % Handshake
        \draw[message_r] (client.east) -- node[midway, above, font=\scriptsize] {1. ClientHello (ciphers, nonce C)} (server.west);
        \draw[message_l] (client.east) -- node[midway, below, font=\scriptsize] {2. ServerHello (cipher choice, cert, nonce S)} (server.west);
        \draw[message_r] (client.east) -- node[midway, above, yshift=0.5cm, font=\scriptsize] {3. ClientKeyExchange ($K_S^+(\text{PMS})$), ChangeCipherSpec, Finished} (server.west);
        \draw[message_l] (client.east) -- node[midway, below, yshift=-0.5cm, font=\scriptsize] {4. ChangeCipherSpec, Finished} (server.west);

        % Data Transfer (Encrypted)
        \node (encrypted_data_label) [below=1.5cm of client, xshift=3cm, font=\small\itshape, text=green] {Trasferimento Dati Crittografati};
        \draw[<->, green, thick, dashed] ($(client.south east) + (0,-0.5)$) -- node[midway, below, font=\scriptsize] {Record SSL} ($(server.south west) + (0,-0.5)$);

        % Vertical lines for phases
        \coordinate (midpoint) at ($(client)!0.5!(server)$);
        \draw[dotted, gray] (midpoint) ++(0,1.5cm) -- (midpoint) ++(0,-2.5cm);
        \node[above=2.5cm of $(client)!0.5!(server)$, font=\small\bfseries] {Handshake};
    \end{tikzpicture}
    \caption{Schema semplificato dell'Handshake SSL/TLS.}
\end{figure}

\subsection{Real SSL: Handshake (dettagli)}
\begin{enumerate}
    \item \textbf{ClientHello:} Client invia lista cipher suite, versione SSL/TLS, nonce client.
    \item \textbf{ServerHello, Certificate, ServerHelloDone:} Server sceglie cipher suite, invia certificato, nonce server.
    \item \textbf{ClientKeyExchange, ChangeCipherSpec, EncryptedHandshakeMessage (Finished):}
    Client verifica certificato server, genera PMS, lo crittografa con chiave pubblica server. Entrambi calcolano MS e chiavi di sessione. Client invia MAC di tutti i messaggi handshake finora, crittografato (Finished).
    \item \textbf{Server: ChangeCipherSpec, EncryptedHandshakeMessage (Finished):}
    Server invia il suo messaggio Finished crittografato.
\end{enumerate}
Gli ultimi due messaggi (Finished) proteggono l'handshake da manomissioni. I due nonce prevengono replay di sessioni.

\subsubsection{Flusso Messaggi Handshake SSL/TLS (Semplificato)}
\label{ssubsec:real_ssl_handshake_flow}
\begin{enumerate}
    \item \textbf{Client $\rightarrow$ Server: ClientHello}
    (Lista CipherSuite supportate dal client, Nonce Client $N_C$, versione SSL/TLS)
    \item \textbf{Server $\rightarrow$ Client: ServerHello, Certificate, ServerKeyExchange (opz.), ServerHelloDone}
    (CipherSuite scelta dal server, Nonce Server $N_S$, Certificato del Server [contenente $K_S^+$], opz. parametri per Diffie-Hellman, fine messaggi server)
    \item \textbf{Client $\rightarrow$ Server: ClientKeyExchange, ChangeCipherSpec, Finished}
    (Client verifica certificato server. Client genera Pre-Master Secret $PMS$. Client invia $K_S^+(PMS)$ [o risultato DH]. Client deriva MasterSecret $MS$ e chiavi di sessione. \texttt{ChangeCipherSpec} indica che i messaggi successivi saranno crittografati. \texttt{Finished} è un MAC di tutti i messaggi handshake finora, crittografato con le nuove chiavi di sessione.)
    \item \textbf{Server $\rightarrow$ Client: ChangeCipherSpec, Finished}
    (Server decrittografa $PMS$, deriva $MS$ e chiavi di sessione. \texttt{ChangeCipherSpec}. \texttt{Finished} è il MAC dei messaggi handshake calcolato dal server, crittografato.)
\end{enumerate}
A questo punto l'handshake è completo e il canale sicuro è stabilito.

\subsubsection{Derivazione delle Chiavi di Sessione in SSL/TLS}
\label{ssubsec:ssl_key_derivation}
Una volta che Client e Server hanno negoziato il Pre-Master Secret (PMS) e scambiato i nonce ($N_C, N_S$), entrambi calcolano il Master Secret (MS) in modo indipendente:
\begin{itemize}
    \item $MS = \text{PRF}(PMS, \text{"master secret"}, N_C \mathbin{\|} N_S)$
    \item PRF è una Pseudo-Random Function, definita nello standard TLS.
\end{itemize}
Dal Master Secret, vengono derivati ulteriori blocchi di chiavi ("key block") usando nuovamente la PRF:
\begin{itemize}
    \item $\text{Key\_Block} = \text{PRF}(MS, \text{"key expansion"}, N_S \mathbin{\|} N_C)$
\end{itemize}
Il Key\_Block viene poi suddiviso per ottenere le chiavi di sessione effettive:
\begin{itemize}
    \item Chiave MAC scrittura client ($M_c$)
    \item Chiave MAC scrittura server ($M_s$)
    \item Chiave crittografia scrittura client ($K_c$)
    \item Chiave crittografia scrittura server ($K_s$)
    \item (Se necessario) Vettori di Inizializzazione (IV) per client e server (per cifrari a blocchi in modalità CBC)
\end{itemize}
Questo processo assicura che ogni sessione utilizzi chiavi uniche e che le chiavi per direzioni e scopi diversi (MAC vs. crittografia) siano indipendenti.

\subsection{SSL Record Protocol}
Dati frammentati $\rightarrow$ Aggiunta MAC $\rightarrow$ Crittografia (frammento+MAC) $\rightarrow$ Header SSL.

\section{Sicurezza a Livello di Rete: IPsec (IP Security)}
\label{sec:ipsec}
Fornisce sicurezza a livello IP (livello 3).

\begin{itemize}
    \item \textbf{\textquotedblleft Blanket coverage\textquotedblright{}:} Protegge tutto il traffico tra due endpoint IPsec.
    \item \textbf{Virtual Private Networks (VPNs):} Traffico crittografato su Internet pubblica.
\end{itemize}

\subsubsection{Formato del Record SSL/TLS}
\label{ssubsec:ssl_record_format}
Ogni record SSL/TLS ha la seguente struttura generale (prima della crittografia del payload):
\begin{verbatim}
+-----------------+----------------+-----------------+
| Content Type (1)| Version (2)    | Length (2)      | Header (5 bytes)
+-----------------+----------------+-----------------+
|                                                 |
|                 Fragment Data (payload)           |
|                                                 |
+-------------------------------------------------+
|                 MAC (es. 20-32 bytes)           |
+-------------------------------------------------+
|                 Padding (variable)              |
+-------------------------------------------------+
|                 Pad Length (1)                  |
+-------------------------------------------------+
\end{verbatim}
Il blocco \texttt{[Fragment Data || MAC || Padding || Pad Length]} viene poi crittografato se la cipher suite lo prevede.
\begin{itemize}
    \item \textbf{Content Type:} Tipo di messaggio (es. handshake, alert, application data).
    \item \textbf{Version:} Versione di SSL/TLS (es. TLS 1.2 è 0x0303).
    \item \textbf{Length:} Lunghezza del frammento di dati crittografati (payload + MAC + padding).
    \item \textbf{MAC:} Message Authentication Code, calcolato sui dati del frammento, un numero di sequenza implicito e altre informazioni dell'header.
    \item \textbf{Padding:} Aggiunto per cifrari a blocchi o per oscurare la lunghezza reale dei dati.
\end{itemize}

\subsection{Servizi IPsec}
Integrità dati, autenticazione origine, prevenzione replay, confidenzialità.

\subsection{Protocolli IPsec}
\begin{itemize}
    \item \textbf{AH (Authentication Header):} Autenticazione, integrità. \textbf{Non} confidenzialità.
    \item \textbf{ESP (Encapsulating Security Payload):} Autenticazione, integrità, \textbf{confidenzialità}. Più usato.
\end{itemize}

\subsection{Modalità IPsec}
\begin{itemize}
    \item \textbf{Transport Mode:} Protegge payload IP. Header IP originale in gran parte intatto. Host-to-host.
    \item \textbf{Tunnel Mode:} Intero datagramma IP originale incapsulato in nuovo datagramma IP. Tipicamente router-to-router (VPN site-to-site) o client-to-router.
\end{itemize}
\textbf{ESP in Tunnel Mode è la più comune per VPN.}

\subsection{Security Associations (SAs)}
\begin{itemize}
    \item Contratto unidirezionale (simplex) tra due entità IPsec. Contiene parametri (chiavi, algoritmi, SPI).
    \item \textbf{SPI (Security Parameter Index):} Identificatore a 32 bit della SA.
    \item \textbf{SAD (Security Association Database):} Database dove gli endpoint IPsec memorizzano le SA.
\end{itemize}

\subsubsection{Parametri Tipici di una Security Association (SA)}
\label{ssubsec:sa_parameters}
Una SA da R1 a R2 (unidirezionale) memorizzata nella SAD di R1 potrebbe contenere:
\begin{itemize}
    \item \textbf{Security Parameter Index (SPI):} Un valore a 32 bit che identifica univocamente la SA presso il ricevitore (R2).
    \item \textbf{Indirizzo IP di destinazione (per R2):} L'endpoint della SA.
    \item \textbf{Protocollo IPsec utilizzato:} AH o ESP.
    \item \textbf{Algoritmo di crittografia (per ESP):} Es. 3DES, AES.
    \item \textbf{Chiave di crittografia (per ESP).}
    \item \textbf{Algoritmo di autenticazione/integrità:} Es. HMAC-MD5, HMAC-SHA1.
    \item \textbf{Chiave di autenticazione/integrità.}
    \item \textbf{Modalità IPsec:} Transport o Tunnel.
    \item \textbf{Lifetime della SA:} Per quanto tempo la SA è valida.
    \item \textbf{(Opzionale) Finestra anti-replay.}
\end{itemize}
Un esempio di SA manuale (come da slide 100 per IKE):
\begin{verbatim}
SPI: 12345
Source IP (interfaccia su R1): 200.168.1.100
Dest IP (interfaccia su R2): 193.68.2.23
Protocollo: ESP
Algoritmo Crittografia: 3DES-cbc
Algoritmo HMAC: MD5
Chiave Crittografia: 0x7aeaca...
Chiave HMAC: 0xc0291f...
\end{verbatim}

\subsection{Datagramma IPsec (Tunnel Mode con ESP)}
\texttt{[New IP Hdr] [ESP Hdr] [Original IP Hdr] [Original Payload] [ESP Trailer] [ESP Auth]}
\begin{itemize}
    \item \textbf{Parte Crittografata:} \texttt{[Original IP Hdr] [Original Payload] [ESP Trailer]}
    \item \textbf{Parte Autenticata (MAC):} \texttt{[ESP Hdr] [Parte Crittografata]}
    \item \textbf{Numeri di Sequenza:} Nell'ESP Hdr, per prevenire replay.
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=0mm, scale=0.8, transform shape]
        \small % Smaller font for the diagram
        \node (newip)   [draw, fill=blue!20, minimum height=0.7cm, minimum width=2.5cm, text=black] {New IP Hdr};
        \node (esph)    [draw, fill=green!30, minimum height=0.7cm, minimum width=2.2cm, right=of newip, text=black] {ESP Hdr};
        \node (origip)  [draw, fill=orange!40, minimum height=0.7cm, minimum width=2.5cm, right=of esph, text=black] {Original IP Hdr};
        \node (origpay) [draw, fill=orange!40, minimum height=0.7cm, minimum width=3.0cm, right=of origip, text=black] {Original Payload};
        \node (esptrl)  [draw, fill=orange!40, minimum height=0.7cm, minimum width=2.5cm, right=of origpay, text=black] {ESP Trailer};
        \node (espauth) [draw, fill=purple!50, minimum height=0.7cm, minimum width=2.2cm, right=of esptrl, text=black] {ESP Auth (ICV)};

        % Braces for encrypted and authenticated parts
        \draw [decorate,decoration={brace,amplitude=5pt,mirror},yshift=-0.5cm]
            (origip.south west) -- (esptrl.south east) node [black,midway,yshift=-0.4cm, text=white] {Encrypted};

        \draw [decorate,decoration={brace,amplitude=5pt},yshift=0.5cm]
            (esph.north west) -- (esptrl.north east) node [black,midway,yshift=0.4cm, text=white] {Authenticated (for ICV)};
    \end{tikzpicture}
    \caption{Struttura del datagramma IPsec (ESP Tunnel Mode).}
\end{figure}

\subsubsection{Struttura Dettagliata Datagramma IPsec (ESP Tunnel Mode)}
\label{ssubsec:ipsec_esp_tunnel_packet}
Un pacchetto IP originale viene trasformato come segue:

\texttt{Original IP Packet: [Orig IP Hdr] [Orig Payload (es. TCP/UDP segment)]}

\textbf{Passaggi di R1 (mittente IPsec):}
\begin{enumerate}
    \item \textbf{Aggiunta Trailer ESP:} Al pacchetto IP originale si aggiunge un ESP Trailer.
    \texttt{[Orig IP Hdr] [Orig Payload] [ESP Trailer (Padding, Pad Length, Next Header)]}
    Il campo "Next Header" indica il tipo di protocollo dell' "Orig IP Hdr" (es. IP).
    \item \textbf{Crittografia (Payload ESP):} La porzione \texttt{[Orig IP Hdr] ... [ESP Trailer]} viene crittografata usando l'algoritmo e la chiave specificati nella SA.
    \texttt{Encrypted\_Data = Enc( [Orig IP Hdr] [Orig Payload] [ESP Trailer] )}
    \item \textbf{Aggiunta Header ESP:} Si antepone l'ESP Header.
    \texttt{[ESP Hdr (SPI, Seq Num)] [Encrypted\_Data]}
    \item \textbf{Calcolo ICV (Authentication):} Si calcola un Integrity Check Value (MAC) sulla porzione \texttt{[ESP Hdr] [Encrypted\_Data]} usando l'algoritmo e la chiave di autenticazione della SA.
    \texttt{ESP\_Auth\_Data (ICV)}
    \item \textbf{Aggiunta Nuovo Header IP:} Si crea un nuovo header IP (modalità tunnel) che instrada il pacchetto tra i gateway IPsec (es. R1 e R2).
    \texttt{[New IP Hdr (src=R1, dst=R2)] [ESP Hdr] [Encrypted\_Data] [ESP\_Auth\_Data (opzionale, se ESP con autenticazione)]}
\end{enumerate}

La struttura finale visualizzata nelle slide (page 93) è:
\begin{verbatim}
+------------+---------+-----------+---------------------+---------+----------+
| New IP     | ESP     | Original  | Original IP         | ESP     | ESP      |
| Header     | Header  | IP Header | Datagram Payload    | Trailer | Auth     |
+------------+---------+-----------+---------------------+---------+----------+
             |<------------------ Encrypted ---------------------->|
|<----------------------- Authenticated (by ESP Auth) ----------------------->|
 (se ESP Auth è presente e copre l'ESP header)
\end{verbatim}
L'ESP Header contiene:
\begin{itemize}
    \item \textbf{SPI (Security Parameter Index):} Identifica la SA al destinatario.
    \item \textbf{Sequence Number:} Contatore per prevenire attacchi di replay.
\end{itemize}
L'ESP Trailer contiene:
\begin{itemize}
    \item \textbf{Padding:} Per allineare il payload ai requisiti del cifrario a blocchi e/o per oscurare la lunghezza.
    \item \textbf{Pad Length:} Lunghezza del padding.
    \item \textbf{Next Header:} Tipo del payload incapsulato (es. IP, TCP, UDP).
\end{itemize}
L'ESP Auth (ICV) è il Message Authentication Code.

\subsection{SPD (Security Policy Database)}
Contiene policy che dicono \textbf{se} e \textbf{quale SA} usare per un dato traffico.
\begin{itemize}
    \item \textbf{SPD:} \textquotedblleft Cosa\textquotedblright{} fare (policy).
    \item \textbf{SAD:} \textquotedblleft Come\textquotedblright{} farlo (parametri SA).
\end{itemize}

\subsection{IKE (Internet Key Exchange)}
Protocollo per negoziare e stabilire dinamicamente le SA IPsec.
\begin{itemize}
    \item \textbf{Autenticazione IKE:}
    \begin{itemize}
        \item \textbf{PSK (Pre-Shared Secret):} Segreto condiviso manualmente.
        \item \textbf{PKI (Public Key Infrastructure):} Chiavi pubbliche/private e certificati.
    \end{itemize}
    \item \textbf{Fasi di IKE:}
    \begin{itemize}
        \item \textbf{Fase 1:} Stabilisce SA IKE bidirezionale (ISAKMP SA). Modalità: Aggressive o Main.
        \item \textbf{Fase 2:} Usa ISAKMP SA per negoziare coppia di SA IPsec.
    \end{itemize}
\end{itemize}

\section{Protezione delle LAN Wireless (Wi-Fi)}
\label{sec:wifi_security}

\subsection{WEP (Wired Equivalent Privacy)}
\textbf{Standard obsoleto e insicuro.}
\begin{itemize}
    \item \textbf{Obiettivi:} Confidenzialità, autorizzazione, integrità (debole), auto-sincronizzazione.
    \item Usa cifrario a flusso \textbf{RC4}.
    \item Chiave RC4 = Chiave WEP condivisa (es. 104 bit) + \textbf{IV (Initialization Vector) di 24 bit}.
    \item L'IV è inviato in chiaro.
    \item \textbf{Crittografia WEP:} (Dati + ICV) $\oplus$ Keystream. ICV è un CRC-32 (debole).
    \item \textbf{Rottura di WEP:} \textbf{Riutilizzo dell'IV}. IV a 24 bit $\rightarrow$ IV si ripetono rapidamente.
    Se $c_1 = p_1 \oplus KS_{IV}$ e $c_2 = p_2 \oplus KS_{IV}$, allora $c_1 \oplus c_2 = p_1 \oplus p_2$.
    Se $p_1$ è noto, si ricava $p_2$ e $KS_{IV}$.
\end{itemize}

\subsubsection{Cifrario a Flusso RC4 e WEP}
\label{ssubsec:wep_rc4_stream}
Un cifrario a flusso genera un \textit{keystream} ($ks$) pseudo-casuale.
\begin{itemize}
    \item \textbf{Input al generatore di keystream WEP:} Chiave WEP condivisa (104 bit) + IV (24 bit per pacchetto). Totale 128 bit.
    \item \textbf{Generazione Keystream:} $ks = \text{RC4}(\text{Chiave WEP} \mathbin{\|} \text{IV})$
    \item \textbf{Crittografia:} Sia $P$ il plaintext del frame (Dati + ICV). Il ciphertext $C$ è:
    $C(i) = P(i) \oplus ks(i)$ (XOR byte per byte)
    \item \textbf{Decrittografia:} $P(i) = C(i) \oplus ks(i)$
\end{itemize}
L'IV è trasmesso in chiaro nel frame 802.11. L'ICV è un CRC-32 sui dati originali, non crittograficamente sicuro.

\subsubsection{Dettagli Attacco di Riutilizzo IV in WEP}
\label{ssubsec:wep_iv_reuse_attack}
Se un IV viene riutilizzato, lo stesso keystream $ks_{IV}$ viene generato.
Supponiamo che Trudy intercetti due pacchetti crittografati con lo stesso IV:
\begin{itemize}
    \item $C_1 = P_1 \oplus ks_{IV}$
    \item $C_2 = P_2 \oplus ks_{IV}$
\end{itemize}
Trudy può calcolare $C_1 \oplus C_2$:
$C_1 \oplus C_2 = (P_1 \oplus ks_{IV}) \oplus (P_2 \oplus ks_{IV}) = P_1 \oplus P_2 \oplus ks_{IV} \oplus ks_{IV} = P_1 \oplus P_2$.
Se Trudy conosce uno dei plaintext (es. $P_1$, un pacchetto ARP noto), può ricavare l'altro:
$P_2 = (C_1 \oplus C_2) \oplus P_1$.
Una volta ottenuto $P_2$, può anche ricavare il keystream: $ks_{IV} = C_2 \oplus P_2$.
Da quel momento, Trudy può decrittografare qualsiasi pacchetto futuro crittografato con lo stesso IV.
Dato che l'IV è solo a 24 bit, ci sono solo $2^{24} \approx 16$ milioni di IV possibili. Su una rete trafficata, gli IV si ripetono rapidamente.

\textbf{Struttura del frame WEP (semplificata):}
\texttt{[802.11 Header] [IV (24bit)] [Encrypted Data (PlaintextData + ICV)] [FCS]}

\subsection{802.11i (WPA2/WPA3): Sicurezza Migliorata}
Sostituisce WEP.
\begin{itemize}
    \item Crittografia più robusta (es. AES-CCMP).
    \item Distribuzione robusta delle chiavi.
    \item Usa \textbf{Authentication Server (AS)} separato dall'Access Point (AP).
    \item \textbf{Quattro Fasi Operative di 802.11i:}
    \begin{enumerate}
        \item \textbf{Discovery:} STA e AP scoprono capacità.
        \item \textbf{Authentication:} STA e AS si autenticano (AP fa da pass-through, spesso con EAP). Generano \textbf{PMK (Pairwise Master Key)}. AS invia PMK ad AP.
        \item \textbf{Key Generation:} STA e AP usano PMK per derivare chiavi temporanee (\textbf{TK}).
        \item \textbf{Data Transfer Protetto:} Dati protetti con TK.
    \end{enumerate}
    \item \textbf{EAP (Extensible Authentication Protocol):} Protocollo end-to-end client (STA) $\leftrightarrow$ AS.
    Incapsulato: EAPoL (STA-AP), RADIUS (AP-AS).
\end{itemize}

\subsubsection{Fasi Operative di 802.11i (Dettagliate)}
\label{ssubsec:80211i_phases_detailed}
\begin{enumerate}
    \item \textbf{Discovery (Scoperta):}
        \begin{itemize}
            \item STA (Stazione, es. laptop) e AP (Access Point) si scambiano informazioni sulle capacità di sicurezza (es. tramite beacon e probe request/response).
        \end{itemize}
    \item \textbf{Authentication (Autenticazione EAP):}
        \begin{itemize}
            \item STA inizia l'autenticazione con l'AP (che agisce da Authenticator).
            \item L'AP inoltra i messaggi EAP (Extensible Authentication Protocol) all'AS (Authentication Server, es. RADIUS). L'AP è un "pass-through".
            \item STA e AS si autenticano reciprocamente (es. usando certificati TLS all'interno di EAP-TLS, o credenziali MSCHAPv2 per EAP-PEAP).
            \item Se l'autenticazione ha successo, STA e AS generano indipendentemente la stessa \textbf{PMK (Pairwise Master Key)}.
            \item L'AS invia la PMK all'AP (protetta, es. tramite attributi RADIUS crittografati).
        \end{itemize}
    \item \textbf{Key Generation (Generazione Chiavi - 4-Way Handshake):}
        \begin{itemize}
            \item AP e STA eseguono un handshake a 4 messaggi.
            \item Scopi:
                \begin{itemize}
                    \item Confermare che entrambi possiedono la PMK.
                    \item Negoziare e generare la \textbf{PTK (Pairwise Transient Key)}. La PTK è derivata dalla PMK, nonce dell'AP (ANonce), nonce della STA (SNonce), e indirizzi MAC di AP e STA.
                    \item La PTK viene suddivisa in:
                        \begin{itemize}
                            \item KCK (Key Confirmation Key): Usata per MAC nell'handshake.
                            \item KEK (Key Encryption Key): Usata per crittografare chiavi di gruppo.
                            \item TK (Temporal Key): Usata per crittografare/decrittografare i dati unicast.
                        \end{itemize}
                    \item Sincronizzare l'installazione delle chiavi.
                    \item (Opzionale) Distribuire la GTK (Group Temporal Key) per il traffico multicast/broadcast.
                \end{itemize}
        \end{itemize}
    \item \textbf{Protected Data Transfer (Trasferimento Dati Protetto):}
        \begin{itemize}
            \item I frame di dati unicast tra STA e AP sono crittografati e autenticati (integrità) usando la TK e algoritmi come AES-CCMP.
        \end{itemize}
\end{enumerate}

\textbf{Diagramma di Livelli EAP (Slide 116):}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=0.3cm,
        layer/.style={rectangle, draw, text=black, thick, minimum width=3.2cm, minimum height=0.7cm, align=center, font=\small},
        device/.style={rectangle, draw, text=black, thick, rounded corners=3pt, minimum width=2.5cm, minimum height=0.8cm, align=center, fill=gray!15, font=\bfseries},
        connection/.style={->, thick, >=Stealth},
        wireless/.style={thick, themeblue, decorate, decoration={snake, amplitude=0.8mm, segment length=2mm}},
    ]

    % Title
    \node[font=\Large\bfseries] (title) {Architettura di Autenticazione EAP};

    % STA (left column)
    \node[device, below=1.5cm of title, xshift=-5cm] (sta) {STA\\(Supplicant)};
    \node[layer, below=of sta, fill=themeblue!20] (sta-method) {Metodo EAP\\(es. TLS)};
    \node[layer, below=of sta-method, fill=green!20] (sta-eap) {EAP};
    \node[layer, below=of sta-eap, fill=yellow!20] (sta-eapol) {EAPoL};

    % AP (center)
    \node[device, below=1.5cm of title] (ap) {AP\\(Authenticator)};
    \node[layer, below=of ap, fill=yellow!20] (ap-eapol) {EAPoL / IEEE 802.11};

    % AS (right column, positioned lower to accommodate full stack)
    \node[device, below=1.5cm of title, xshift=5cm] (as) {AS\\(Server Auth)};
    \node[layer, below=of as, fill=themeblue!20] (as-method) {Metodo EAP\\(es. TLS)};
    \node[layer, below=of as-method, fill=green!20] (as-eap) {EAP};
    \node[layer, below=of as-eap, fill=orange!20] (as-radius) {RADIUS};
    \node[layer, below=of as-radius, fill=red!20] (as-udp) {UDP/IP};

    % Wireless connection
    \draw[wireless] (sta-eapol.east) -- (ap-eapol.west);
    \node[above, themeblue, font=\footnotesize] at ($(sta-eapol.east)!0.5!(ap-eapol.west) + (0,0.4)$) {Wireless};

    % Wired connection
    \draw[connection, red, thick] (ap-eapol.east) -- (as-udp.west);
    \node[above, red, font=\footnotesize] at ($(ap-eapol.east)!0.5!(as-udp.west) + (0,0.4)$) {Rete Cablata};

    % End-to-end EAP method (conceptual)
    \draw[connection, purple, thick, dashed] (sta-eap.east) to[out=0, in=180] (as-eap.west);
    \node[below=0.1cm, purple, font=\footnotesize] at ($(sta-eap.east)!0.5!(as-eap.west)$) {Tunnel EAP End-to-End};

    % Role labels
    \node[below=0.2cm of sta-eapol, font=\large\bfseries, color=themeblue] {Cliente};
    \node[below=0.2cm of ap-eapol, font=\large\bfseries, color=orange] {Relay};
    \node[below=0.3cm of as-udp, font=\large\bfseries, color=red] {Server};

    \end{tikzpicture}
    \caption{Architettura di autenticazione EAP con i suoi componenti e protocolli.}
\end{figure}

\section{Sicurezza Operativa: Firewall e IDS}
\label{sec:firewall_ids}

\subsection{Firewall}
Isolano rete interna, permettendo/bloccando pacchetti secondo regole.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=2cm,
        computer/.style={rectangle, draw, fill=gray!20, minimum width=1cm, minimum height=0.8cm, rounded corners=2pt, text=black},
        server/.style={rectangle, draw, fill=blue!20, minimum width=1.2cm, minimum height=1cm, rounded corners=2pt, text=black},
        firewall/.style={rectangle, draw, fill=red!70, text=white, font=\bfseries, minimum width=1.5cm, minimum height=2cm, rounded corners=3pt},
        cloud/.style={ellipse, draw, fill=blue!30, minimum width=3cm, minimum height=1.5cm, text=black},
        zone/.style={rectangle, draw, dashed, rounded corners=5pt, minimum width=4cm, minimum height=3cm}
    ]
        
        % Trusted Zone (Internal Network)
        \node[zone, fill=green!20] (trusted_zone) at (0,0) {};
        \node[above=0.1cm of trusted_zone.north, font=\small\bfseries, text=green] {TRUSTED ZONE};
        \node[below=0.1cm of trusted_zone.south, font=\small, text width=3.5cm, align=center] {Rete Amministrata\\(``good guys'')};
        
        % Internal devices
        \node[computer] (pc1) at (-1, 0.5) {PC};
        \node[computer] (pc2) at (1, 0.5) {PC};
        \node[server] (server) at (0, -0.8) {Server};
        
        % Internal switch/hub representation
        \coordinate (internal_hub) at (0, -0.1);
        \draw[thick] (pc1) -- (internal_hub);
        \draw[thick] (pc2) -- (internal_hub);
        \draw[thick] (server) -- (internal_hub);
        
        % Firewall
        \node[firewall] (fw) at (6, 0) {FIREWALL};
        
        % Connection from internal network to firewall
        \draw[thick, ->] (internal_hub) -- node[above, font=\small, xshift=0.8cm] {traffico interno} (fw.west);
        
        % Untrusted Zone (Internet)
        \node[zone, fill=red!30] (untrusted_zone) at (12,0) {};
        \node[above=0.1cm of untrusted_zone.north, font=\small\bfseries, text=red] {UNTRUSTED ZONE};
        \node[below=0.1cm of untrusted_zone.south, font=\small, text width=3.5cm, align=center] {Internet\\(``bad guys'')};
        
        % Internet cloud
        \node[cloud] (internet) at (12, 0) {Internet};
        
        % Connection from firewall to internet
        \draw[thick, <->] (fw.east) -- node[above, font=\small] {traffico filtrato} (internet.west);
        
        % Firewall rules annotations
        \node[below=1.5cm of fw, font=\small, text width=4cm, align=center, fill=yellow!20, rounded corners=2pt, text=black] (rules) {
            \textbf{Regole Firewall:}\\
            • Blocca traffico sospetto\\
            • Permette connessioni autorizzate\\
            • Log degli accessi
        };
        
        % Legend
        \node[right=1cm of rules, font=\small] (legend) {
            \begin{tabular}{ll}
                \textcolor{green!60!black}{$\bullet$} & Zona Fidata \\
                \textcolor{red!60!black}{$\bullet$} & Zona Non Fidata \\
                $\rightarrow$ & Traffico Outbound \\
                $\leftrightarrow$ & Traffico Bidirezionale Filtrato
            \end{tabular}
        };
        
    \end{tikzpicture}
    \caption{Architettura Firewall: Separazione tra Zona Fidata e Non Fidata}
\end{figure}

\subsubsection{Perché usare i Firewall?}
\begin{itemize}
    \item Prevenire attacchi DoS (es. SYN flooding).
    \item Prevenire modifiche/accessi illegali a dati interni.
    \item Consentire solo accessi autorizzati.
\end{itemize}

\subsubsection{Tipi di Firewall}
\begin{enumerate}
    \item \textbf{Stateless Packet Filters:}
    \begin{itemize}
        \item Router firewall, esamina pacchetti individualmente.
        \item Decisione basata su IP src/dest, porte TCP/UDP, tipo ICMP, bit TCP SYN/ACK.
        \item \textbf{ACL (Access Control Lists):} Tabelle di regole (azione, condizione).
    \end{itemize}
    \item \textbf{Stateful Packet Filters:}
    \begin{itemize}
        \item Traccia lo stato di ogni connessione TCP.
        \item Determina se i pacchetti \textquotedblleft hanno senso\textquotedblright{} nel contesto della connessione.
        \item Timeout connessioni inattive.
    \end{itemize}
    \item \textbf{Application Gateways (Proxy Firewall):}
    \begin{itemize}
        \item Filtrano sui \textbf{dati dell'applicazione} oltre che sugli header.
        \item Agiscono come proxy per specifiche applicazioni.
        \item Client deve essere configurato per usare il proxy.
    \end{itemize}
\end{enumerate}
\textbf{Esempio ACL (Stateless):}
\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
        \hline
        \textbf{Azione} & \textbf{IP Src} & \textbf{IP Dest} & \textbf{Proto} & \textbf{Porta Src} & \textbf{Porta Dest} & \textbf{Flag} \\ \hline
        allow & 222.22/16 & ext. & TCP & $>$1023 & 80 & any \\ \hline
        allow & ext. & 222.22/16 & TCP & 80 & $>$1023 & ACK \\ \hline
        deny  & all & all & all & all & all & all \\ \hline
    \end{tabular}
    \caption{Esempio semplificato di Access Control List (ACL).}
\end{table}


\subsubsection{Limitazioni di Firewall e Gateway}
\begin{itemize}
    \item IP Spoofing.
    \item Complessità con molte app che necessitano gateway dedicati.
    \item Client software deve essere configurato per il proxy.
    \item Trade-off: comunicazione vs. sicurezza.
\end{itemize}

\subsection{Intrusion Detection Systems (IDS)}
Rilevano attività sospette o dannose.
\begin{itemize}
    \item \textbf{Deep Packet Inspection (DPI):} Guardano il \textbf{contenuto} dei pacchetti (vs. firme virus, stringhe attacco).
    \item \textbf{Correlazione tra pacchetti multipli:} Rilevano port scanning, network mapping, DoS.
    \item Posizionati in vari punti della rete (interna, DMZ).
\end{itemize}

\section{Recap della Sicurezza di Rete}
\label{sec:recap_sicurezza}

Questa sezione riassume i concetti fondamentali della sicurezza di rete, con esempi pratici per illustrarne l'applicazione.

\subsection{Pilastri della Sicurezza}
\begin{itemize}
    \item \textbf{Riservatezza (Confidentiality):} Solo le parti autorizzate possono accedere/comprendere l'informazione.
    \begin{itemize}
        \item \textbf{Tecnica principale:} Crittografia (simmetrica e asimmetrica).
        \item \emph{Esempio Pratico:} Quando inserisci la password per l'online banking, questa viene crittografata per impedire a Trudy di leggerla se la intercettasse.
        \item \emph{Dall'esame (Q3 Giu2022, Q4 Mag2023, Q4 Lug2023):} La necessità di \textit{privacy} per il messaggio \texttt{m2} o per i messaggi scambiati implica la crittografia.
    \end{itemize}

    \item \textbf{Autenticazione (Authentication):} Verificare l'identità di un utente, dispositivo o servizio.
    \begin{itemize}
        \item \textbf{Tecniche principali:} Password, certificati digitali, firme digitali, protocolli di autenticazione (con nonce).
        \item \emph{Esempio Pratico:} Il server della banca vuole essere sicuro che sei tu a fare login (autenticazione utente); tu vuoi essere sicuro di parlare con il vero sito della banca (autenticazione server).
        \item \emph{Dall'esame (Q3 Giu2022, Q4 Mag2023):} La \textit{garanzia del mittente} (es. "solo Bob può averlo spedito") è un requisito di autenticazione.
    \end{itemize}

    \item \textbf{Integrità del Messaggio (Message Integrity):} Assicurarsi che il messaggio non sia stato alterato durante la trasmissione.
    \begin{itemize}
        \item \textbf{Tecniche principali:} Funzioni hash crittografiche, Message Authentication Codes (MAC), firme digitali.
        \item \emph{Esempio Pratico:} Se invii un bonifico da 100€, l'integrità garantisce che la banca riceva 100€ e non 10.000€ a causa di una modifica da parte di Trudy.
        \item \emph{Dall'esame (Q4 Mag2023):} L'integrità dei messaggi \texttt{m1} e \texttt{m2} è un requisito esplicito.
    \end{itemize}

    \item \textbf{Non Ripudio (Non-Repudiation):} Impedire che il mittente neghi di aver inviato un messaggio.
    \begin{itemize}
        \item \textbf{Tecnica principale:} Firme digitali.
        \item \emph{Esempio Pratico:} Una firma digitale su un contratto elettronico impedisce al firmatario di negare successivamente di averlo approvato.
        \item \emph{Dall'esame (Q3 Giu2022):} La garanzia di non ripudiabilità per il messaggio \texttt{M1}.
    \end{itemize}

    \item \textbf{Disponibilità (Availability):} I servizi e i dati devono essere accessibili agli utenti autorizzati quando necessario.
    \begin{itemize}
        \item \textbf{Contromisure:} Protezione da attacchi DoS/DDoS, ridondanza.
        \item \emph{Esempio Pratico:} Il sito web dell'università deve essere raggiungibile dagli studenti, non reso inaccessibile da un attacco.
    \end{itemize}

    \item \textbf{Prevenzione del Replay (No-Replay):} Impedire a un attaccante di intercettare un messaggio valido e riutilizzarlo in un secondo momento.
    \begin{itemize}
        \item \textbf{Tecniche principali:} Nonce, numeri di sequenza, timestamp.
        \item \emph{Esempio Pratico:} Evitare che Trudy registri una transazione di login valida e la riproduca per accedere all'account di Alice.
        \item \emph{Dall'esame (Q3 Giu2022, Q4 Lug2023):} La garanzia di \textit{non Replay} per il messaggio \texttt{m2} o per i messaggi scambiati.
    \end{itemize}
\end{itemize}

\subsection{Primitive Crittografiche Fondamentali}
\begin{itemize}
    \item \textbf{Crittografia Simmetrica ($K_S$):} Stessa chiave per crittografare e decrittografare.
    \begin{itemize}
        \item \textbf{Algoritmi comuni:} AES (Advanced Encryption Standard), DES (obsoleto).
        \item \textbf{Vantaggi:} Veloce ed efficiente per grandi quantità di dati.
        \item \textbf{Svantaggi:} Problema della distribuzione sicura della chiave condivisa $K_S$.
        \item \emph{Esempio Pratico:} Crittografare il contenuto di un'email con AES dopo aver scambiato la chiave AES in modo sicuro.
    \end{itemize}

    \item \textbf{Crittografia Asimmetrica (a Chiave Pubblica $K^+, K^-$):} Coppia di chiavi (pubblica e privata).
    \begin{itemize}
        \item \textbf{Algoritmi comuni:} RSA.
        \item \textbf{Uso per Riservatezza:} Si crittografa con la chiave pubblica ($K^+$) del destinatario, si decrittografa con la sua chiave privata ($K^-$).
        \item \textbf{Uso per Autenticazione/Firma:} Si firma con la propria chiave privata ($K^-$), si verifica con la propria chiave pubblica ($K^+$).
        \item \textbf{Vantaggi:} Risolve il problema della distribuzione delle chiavi per la crittografia simmetrica (usandola per scambiare $K_S$), abilita le firme digitali.
        \item \textbf{Svantaggi:} Computazionalmente più costosa (lenta) della crittografia simmetrica.
        \item \emph{Esempio Pratico:} Usare RSA per crittografare una chiave di sessione AES che verrà poi usata per la comunicazione vera e propria.
    \end{itemize}

    \item \textbf{Funzioni Hash Crittografiche ($H(m)$):} Producono un "fingerprint" (digest) di lunghezza fissa da un messaggio di lunghezza variabile.
    \begin{itemize}
        \item \textbf{Proprietà chiave:} Resistenza alla preimmagine (one-way), resistenza alla seconda preimmagine, resistenza alle collisioni.
        \item \textbf{Algoritmi comuni:} SHA-256, SHA-512 (MD5 e SHA-1 sono considerati insicuri o deboli).
        \item \emph{Esempio Pratico:} Usate per verificare l'integrità dei file scaricati o come parte delle firme digitali.
    \end{itemize}

    \item \textbf{Firme Digitali:} Combinano hashing e crittografia asimmetrica.
    \begin{itemize}
        \item \textbf{Processo (Bob firma $m$):} Bob calcola $H(m)$, poi crittografa $H(m)$ con la sua chiave privata $K_B^-$. Il risultato è la firma.
        \item \textbf{Verifica (Alice verifica la firma di Bob):} Alice ricalcola $H(m)$ dal messaggio ricevuto. Decrittografa la firma ricevuta usando la chiave pubblica di Bob $K_B^+$. Se i due hash coincidono, la firma è valida e il messaggio è integro e autenticato.
        \item \textbf{Forniscono:} Autenticazione del mittente, integrità del messaggio, non ripudio.
        \item \emph{Esempio Pratico:} Firmare digitalmente un'email per garantirne l'autenticità e l'integrità.
    \end{itemize}

    \item \textbf{Certificati Digitali e Autorità di Certificazione (CA):}
    \begin{itemize}
        \item \textbf{Problema:} Come faccio a sapere che una chiave pubblica appartiene veramente a Bob e non a Trudy che si finge Bob (attacco Man-in-the-Middle)?
        \item \textbf{Soluzione:} Una CA (entità fidata) emette un certificato digitale che lega un'identità (es. Bob) alla sua chiave pubblica. La CA firma digitalmente questo certificato con la propria chiave privata.
        \item Chiunque voglia verificare la chiave pubblica di Bob può ottenere il suo certificato e verificarne la firma usando la chiave pubblica della CA (che deve essere conosciuta e fidata).
        \item \emph{Esempio Pratico:} Il certificato SSL/TLS del sito della tua banca, firmato da una CA come Let's Encrypt o DigiCert.
    \end{itemize}
\end{itemize}

\subsection{Protocolli e Meccanismi di Sicurezza Chiave}

\subsubsection{Autenticazione degli Endpoint e Scambio di Chiavi}
\begin{itemize}
    \item \textbf{Nonce (Number used ONCE):} Valore casuale usato per prevenire attacchi di replay.
    \begin{itemize}
        \item \emph{Esempio Pratico (Protocollo ap4.0):} Bob invia un nonce $R$ ad Alice. Alice deve restituire $R$ crittografato con la chiave condivisa $K_{A-B}(R)$ per dimostrare di essere "live" e di conoscere la chiave.
    \end{itemize}
    \item \textbf{Attacco Man-in-the-Middle (MITM):} Trudy si interpone tra Alice e Bob, facendo credere ad Alice di parlare con Bob e a Bob di parlare con Alice, intercettando e/o modificando tutta la comunicazione. I certificati digitali aiutano a prevenire il MITM durante lo scambio di chiavi pubbliche.
\end{itemize}

\subsubsection{Protezione delle E-mail (es. PGP/GPG)}
\begin{itemize}
    \item \textbf{Obiettivo combinato:} Riservatezza, autenticazione, integrità.
    \item \textbf{Schema tipico (Alice invia a Bob):}
    \begin{enumerate}
        \item Alice firma $H(m)$ con la sua chiave privata $K_A^-$.
        \item Alice genera una chiave simmetrica di sessione $K_S$.
        \item Alice crittografa il messaggio $m$ e la sua firma con $K_S$.
        \item Alice crittografa $K_S$ con la chiave pubblica di Bob $K_B^+$.
        \item Alice invia a Bob il messaggio crittografato e la chiave di sessione crittografata.
    \end{enumerate}
\end{itemize}

\subsubsection{SSL/TLS (Secure Sockets Layer / Transport Layer Security)}
\begin{itemize}
    \item \textbf{Scopo:} Fornire un canale di comunicazione sicuro (riservatezza, integrità, autenticazione server, opzionalmente client) sopra TCP. Usato per HTTPS.
    \item \textbf{Fasi principali:}
    \begin{enumerate}
        \item \textbf{Handshake:}
        \begin{itemize}
            \item Client e Server negoziano algoritmi crittografici (cipher suite).
            \item Il Server invia il suo certificato digitale (contenente $K_{Server}^+$).
            \item Il Client verifica il certificato del Server.
            \item Il Client genera un \textit{Pre-Master Secret} (PMS), lo crittografa con $K_{Server}^+$, e lo invia al Server.
            \item Entrambi derivano indipendentemente il \textit{Master Secret} (MS) e da esso le chiavi di sessione simmetriche (per crittografia e MAC).
            \item Messaggi `Finished` scambiati per verificare l'integrità dell'handshake.
        \end{itemize}
        \item \textbf{Trasferimento Dati:} I dati applicativi sono frammentati in record. Ogni record include un MAC (calcolato con una chiave di sessione MAC) ed è poi crittografato con una chiave di sessione di crittografia. I numeri di sequenza sono impliciti o espliciti per prevenire replay.
    \end{enumerate}
    \item \emph{Dall'esame (Q4 Lug2023, stream di N messaggi):} Il protocollo descritto per inviare N messaggi segreti ordinati da Alice a Bob, con l'ultimo messaggio N identificato, assomiglia molto a come SSL/TLS gestisce i record di dati: uso di chiavi di sessione, MAC per integrità e autenticazione per messaggio, e crittografia per riservatezza, con meccanismi per ordinamento e fine-stream.
\end{itemize}

\subsubsection{IPsec (IP Security)}
\begin{itemize}
    \item \textbf{Scopo:} Fornire sicurezza a livello di rete IP (Layer 3). Spesso usato per VPN (Virtual Private Networks).
    \item \textbf{Protocolli principali:}
    \begin{itemize}
        \item \textbf{AH (Authentication Header):} Fornisce autenticazione dell'origine e integrità dei dati. Non fornisce riservatezza.
        \item \textbf{ESP (Encapsulating Security Payload):} Fornisce autenticazione, integrità E riservatezza (crittografia).
    \end{itemize}
    \item \textbf{Modalità operative:}
    \begin{itemize}
        \item \textbf{Transport Mode:} Protegge il payload del pacchetto IP originale. Tipicamente host-to-host.
        \item \textbf{Tunnel Mode:} Incapsula l'intero pacchetto IP originale in un nuovo pacchetto IP. Tipicamente gateway-to-gateway (VPN site-to-site) o client-to-gateway (accesso VPN remoto).
    \end{itemize}
    \item \textbf{SA (Security Association):} Contratto unidirezionale che definisce algoritmi, chiavi, SPI (Security Parameter Index) usati tra due peer IPsec. Memorizzate nella SAD (Security Association Database).
    \item \textbf{IKE (Internet Key Exchange):} Protocollo per negoziare e stabilire dinamicamente le SA IPsec.
    \item \emph{Esempio Pratico:} Un dipendente si connette da casa alla rete aziendale tramite una VPN IPsec, creando un "tunnel" crittografato attraverso Internet.
\end{itemize}

\subsubsection{Sicurezza delle Reti Wireless (Wi-Fi)}
\begin{itemize}
    \item \textbf{WEP (Wired Equivalent Privacy):} \textbf{Obsoleto e insicuro.} Vulnerabile a causa del riutilizzo dell'IV (Initialization Vector) a 24 bit e di un ICV debole (CRC32).
    \item \textbf{802.11i (WPA2/WPA3):} Standard di sicurezza moderni.
    \begin{itemize}
        \item Usano crittografia robusta (es. AES-CCMP).
        \item Autenticazione robusta tramite un Authentication Server (AS, es. RADIUS) e il protocollo EAP (Extensible Authentication Protocol) tra la stazione (STA) e l'AS, con l'Access Point (AP) che fa da pass-through.
        \item Derivazione gerarchica delle chiavi: PMK (Pairwise Master Key) generata durante l'autenticazione, usata per derivare chiavi temporanee (TK) per la sessione.
    \end{itemize}
    \item \emph{Esempio Pratico:} Connettersi alla rete Wi-Fi dell'università (che usa 802.1X/EAP con WPA2/3 Enterprise) o alla propria rete domestica protetta da WPA2/3-Personal (PSK).
\end{itemize}

\subsection{Sicurezza Operativa Perimetrale}
\begin{itemize}
    \item \textbf{Firewall:} Dispositivi che filtrano il traffico di rete tra diverse zone di sicurezza (es. rete interna e Internet).
    \begin{itemize}
        \item \textbf{Stateless Packet Filters:} Prendono decisioni pacchetto per pacchetto basate su header (IP src/dest, porte, protocollo). Usano ACL (Access Control Lists).
        \item \textbf{Stateful Packet Filters:} Mantengono traccia dello stato delle connessioni (es. TCP). Permettono solo traffico che "ha senso" nel contesto di una connessione stabilita.
        \item \textbf{Application Gateways (Proxy Firewall):} Operano a livello applicativo, possono ispezionare il contenuto dei dati e agire come intermediari per specifiche applicazioni (es. proxy HTTP).
        \item \emph{Esempio Pratico:} Un firewall aziendale che blocca tutto il traffico in entrata tranne le connessioni HTTPS (porta 443) verso il server web pubblico e le connessioni VPN IPsec verso il gateway VPN.
    \end{itemize}
    \item \textbf{Intrusion Detection Systems (IDS):} Monitorano il traffico di rete o i log di sistema alla ricerca di attività sospette o malevole.
    \begin{itemize}
        \item \textbf{Deep Packet Inspection (DPI):} Analizzano il contenuto dei pacchetti.
        \item Possono rilevare firme di attacchi noti, anomalie comportamentali, scansioni di porte.
        \item \emph{Esempio Pratico:} Un IDS che rileva un numero anomalo di tentativi di connessione falliti verso un server, segnalando un possibile attacco brute-force.
    \end{itemize}
\end{itemize}

\subsection{Scenario Complesso (Ispirato da Esame Q4 Maggio 2023)}
Alice deve inviare $m1$ a Bob e $m2$ a Charlie con:
\begin{itemize}
    \item \textbf{Confidenzialità:} Trudy non deve leggere $m1$ o $m2$.
    \item \textbf{Autenticazione del mittente (Alice):} Bob e Charlie devono essere certi che i messaggi provengano da Alice.
    \item \textbf{Integrità:} $m1$ e $m2$ non devono essere modificati.
\end{itemize}
Se Bob e Charlie poi si scambiano i messaggi, questo è un passo successivo. L'attacco di Trudy è sulla comunicazione Alice $\leftrightarrow$ Bob.

\textbf{Possibile Soluzione per Alice (invio iniziale):}
Alice deve trattare le due spedizioni separatamente, usando i principi della secure e-mail:
\begin{enumerate}
    \item \textbf{Per Bob ($m1$):}
    \begin{itemize}
        \item Alice firma $H(m1)$ con $K_A^-$.
        \item Alice genera $K_{S1}$ (chiave simmetrica per $m1$).
        \item Alice crittografa $(m1 \text{ + firma di } m1)$ con $K_{S1}$.
        \item Alice crittografa $K_{S1}$ con $K_B^+$.
        \item Alice invia $(K_{S1}(m1 + \text{firma})) \text{ e } K_B^+(K_{S1})$ a Bob.
    \end{itemize}
    \item \textbf{Per Charlie ($m2$):}
    \begin{itemize}
        \item Alice firma $H(m2)$ con $K_A^-$.
        \item Alice genera $K_{S2}$ (chiave simmetrica per $m2$).
        \item Alice crittografa $(m2 \text{ + firma di } m2)$ con $K_{S2}$.
        \item Alice crittografa $K_{S2}$ con $K_C^+$.
        \item Alice invia $(K_{S2}(m2 + \text{firma})) \text{ e } K_C^+(K_{S2})$ a Charlie.
    \end{itemize}
\end{enumerate}
\textbf{Difesa da Trudy (attacco Alice $\leftrightarrow$ Bob):} Bob, ricevendo il messaggio da Alice, decrittografa $K_{S1}$ usando $K_B^-$, poi usa $K_{S1}$ per decrittografare il messaggio e la firma. Verifica la firma usando $K_A^+$. Se Trudy modifica il messaggio crittografato o la chiave crittografata, la decrittografia fallirà o la verifica della firma fallirà. L'uso di chiavi pubbliche certificate (non esplicitato nell'esame, ma best practice) preverrebbe MITM sullo scambio delle chiavi pubbliche.

\end{document}